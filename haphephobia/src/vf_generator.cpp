#include "haphephobia/vf_generator.h"
#include "haphephobia/create_vfs.h"

// - Constructor
VFGenerationServer::VFGenerationServer()
{
    nh_.getParam("/surface_repair/processing/virtual_fixtures/generation/vf_surface_offset", surface_offset_);
    nh_.getParam("/surface_repair/processing/virtual_fixtures/generation/vf_vox_leaf_size", voxel_leaf_size_);
    nh_.getParam("/surface_repair/general/output_frame", output_frame_);
    nh_.getParam("/robot/virtual_fixtures/base/reference_axis", reference_axis_);

    ros::ServiceServer vf_generation_service_ = nh_.advertiseService("vf_generation", &VFGenerationServer::generationCallback, this);
    ros::spin();
}

// - Primary callback
bool VFGenerationServer::generationCallback (haphephobia::create_vfs::Request &req, haphephobia::create_vfs::Response &res)
{
    // - Output will be this vector filled with clouds of individual fixtures corresponding to cluster cloud generated by clustering server
    std::vector<sensor_msgs::PointCloud2> clusters {};
    std::vector<sensor_msgs::PointCloud2> fixtures {};
    std::vector<geometry_msgs::Pose> goal_poses {};
    std::vector<geometry_msgs::Pose> camera_poses {};

    // - cloud resampling params
    bool should_resample {};
    nh_.getParam("/surface_repair/processing/virtual_fixtures/generation/resample_cluster_points", should_resample);
    float resample_search_radius {};
    bool use_normals_neighbors;
    int num_normals_neighbors {};
    bool use_normals_radius;
    float normals_radius {};
    if (should_resample) {
        nh_.getParam("/surface_repair/processing/virtual_fixtures/generation/resample_search_radius", resample_search_radius);
        if (!nh_.param<bool>("/surface_repair/processing/normals/use_normals_neighbors", use_normals_neighbors, false));
        if (!nh_.param<int>("/surface_repair/processing/normals/num_normals_neighbors", num_normals_neighbors, 50));
        if (!nh_.param<bool>("/surface_repair/processing/normals/use_normals_radius", use_normals_radius, true));
        if (!nh_.param<float>("/surface_repair/processing/normals/normals_radius", normals_radius, 0.2));
    }
    bool should_upsample {};
    nh_.getParam("/surface_repair/processing/virtual_fixtures/generation/upsample_cluster_points", should_upsample);
    float upsample_density;
    if (should_upsample) {
        nh_.getParam("/surface_repair/processing/virtual_fixtures/generation/upsample_leaf_size", upsample_density);
    }

    // - params related to keeping the robot on the floor and vf generation
    nh_.getParam("/robot/virtual_fixtures/base/bias_offset", base_bias_offset_);
    nh_.getParam("/robot/virtual_fixtures/base/ground_base", ground_base_);
    nh_.getParam("/robot/virtual_fixtures/base/z_offset", base_z_offset_);
    nh_.getParam("/robot/virtual_fixtures/base/fixed_base_height", fixed_base_height_);

    // - splitting clusters to make sure we repair the correct side
    std::vector<sensor_msgs::PointCloud2> raw_clusters {};
    VFGenerationServer::splitClusters(req.clusters, raw_clusters);
    ROS_INFO_STREAM(">> Through splitting clusters; " << raw_clusters.size() << " total.");

    // - Loop through input list of pc2 messages, convert to pcl
    for (sensor_msgs::PointCloud2 cloud_msg : raw_clusters) {
        
        PointCloud::Ptr raw_cloud (new PointCloud);
        pcl::fromROSMsg(cloud_msg, *raw_cloud);

        PointCloud::Ptr full_cloud (new PointCloud);
        if (raw_cloud->points.size() > 0) {
            // - Resampling option to reduce noise for surface reconstruction
            PointCloud::Ptr resampled_cloud (new PointCloud);
            if ((raw_cloud->points.size() > 0) && (should_resample)) {
                pcl::search::KdTree<PointT>::Ptr smoothing_tree (new pcl::search::KdTree<PointT> ());
                pcl::MovingLeastSquares<PointT, PointT> mls;
                mls.setComputeNormals(false);
                mls.setInputCloud(raw_cloud);
                mls.setPolynomialOrder(2);
                mls.setSearchMethod(smoothing_tree);
                mls.setSearchRadius(resample_search_radius);
                mls.process(*resampled_cloud);
            } else {
                pcl::copyPointCloud(*raw_cloud, *resampled_cloud);
            }

            // - Upsampling to increase density of the target surface
            PointCloud::Ptr upsampled_cloud (new PointCloud);
            if ((should_upsample) && (resampled_cloud->points.size() > 0)) {
                VFGenerationServer::upsampleCloud(resampled_cloud, upsampled_cloud);
                // pcl::io::savePCDFileASCII("/home/steven/cloud.pcd", *resampled_cloud);
                // pcl::io::savePCDFileASCII("/home/steven/cloud_upsample.pcd", *upsampled_cloud);
                ROS_INFO_STREAM("Cloud size increased from " << resampled_cloud->points.size() << " to " << upsampled_cloud->points.size() << ".");
            } else {
                pcl::copyPointCloud(*resampled_cloud, *upsampled_cloud);
            }
            pcl::copyPointCloud(*upsampled_cloud, *full_cloud);

        } else {
            pcl::copyPointCloud(*raw_cloud, *full_cloud);
        }

        PointCloud::Ptr cloud (new PointCloud);
        VFGenerationServer::downsampleCloud(full_cloud, raw_cloud, cloud, voxel_leaf_size_);
        // pcl::io::savePCDFileASCII("/home/steven/cloud_downsample.pcd", *cloud);
        ROS_INFO_STREAM(">> Cloud size reduced from " << full_cloud->points.size() << " to " << cloud->points.size() << ".");

        pcl::PointCloud<pcl::PointNormal>::Ptr cloud_fixtures (new pcl::PointCloud<pcl::PointNormal>);

        // - For each, extend normal by an input factor and generate a new point with normal vector inverted (pointing toward the original normal)
        // - Also, collect info about position and normals to construct poses for repair
        std::vector<float> position_sums {0.f, 0.f, 0.f};
        std::vector<float> normal_sums {0.f, 0.f, 0.f};
        
        int error_counter {};
        for (int i = 0; i < cloud->points.size(); i++) {
            pcl::PointNormal fixture;

            // - Creating normal, which can be reinterpreted for direction later
            fixture.normal_x = -1 * cloud->points[i].normal_x;
            fixture.normal_y = -1 * cloud->points[i].normal_y;
            fixture.normal_z = -1 * cloud->points[i].normal_z;

            // - Projecting 
            fixture.x = cloud->points[i].x + surface_offset_ * cloud->points[i].normal_x;
            fixture.y = cloud->points[i].y + surface_offset_ * cloud->points[i].normal_y;
            fixture.z = cloud->points[i].z + surface_offset_ * cloud->points[i].normal_z;

            // - Although normals are previously calculated using the viewpoints associated with the scan, a check here is not a bad idea to make sure they are correct
            // - Making sure fixture is projected to the correct side
            float vp_a {cloud->points[i].x - cloud->points[i].sensor_a};
            float vp_b {cloud->points[i].y - cloud->points[i].sensor_b};
            float vp_c {cloud->points[i].z - cloud->points[i].sensor_c};

            // - determining this by projecting the fixture viewpoint vector onto the point viewpoint vector and seeing if it's greater than the length of the point vp vector
            // - ie. a.b / ||b|| > ||b||
            std::vector<float> fixture_vp {fixture.x - cloud->points[i].sensor_a, fixture.y - cloud->points[i].sensor_b, fixture.z - cloud->points[i].sensor_c};
            double dot_product {vp_a * fixture_vp[0] + vp_b * fixture_vp[1] + vp_c * fixture_vp[2]};
            double mag {sqrt(pow(vp_a, 2) + pow(vp_b, 2) + pow(vp_c, 2))};
            // ROS_INFO_STREAM("Dot product: " << dot_product / mag << "\n" << "VP mag: " << mag);
            
            if ((dot_product / mag) > sqrt(pow(vp_a, 2) + pow(vp_b, 2) + pow(vp_c, 2))) {
                error_counter++;
                continue;
            }
            // - Everything after this point only uses the points that contribute to fixtures because of the guard clause above

            // - Adding the new fixture point with location and orientation to the fixture cloud generated for just the current cluster
            cloud_fixtures->push_back(fixture);

            // - Collecting info related to viewpoint generation
            position_sums[0] += cloud->points[i].x;
            position_sums[1] += cloud->points[i].y;
            position_sums[2] += cloud->points[i].z;
            normal_sums[0] += cloud->points[i].normal_x;
            normal_sums[1] += cloud->points[i].normal_y;
            normal_sums[2] += cloud->points[i].normal_z;
        }

        // - Checking to see if all fixtures are on the wrong side (and continuing if so)
        if (cloud_fixtures->points.size() == 0) {
            ROS_INFO_STREAM("[VF GenerationServer] All fixtures for cluster on incorrect side of object. Entire fixture deleted from consideration.");
            continue;
        }

        pcl::PointCloud<pcl::PointNormal>::Ptr cloud_fixtures_downsampled (new pcl::PointCloud<pcl::PointNormal>);
        pcl::copyPointCloud(*cloud_fixtures, *cloud_fixtures_downsampled);

        if (error_counter > 0) {
            float fraction_incorrect {static_cast<float>(error_counter) / cloud->points.size()};
            ROS_INFO_STREAM("[VFGenerationServer] " << error_counter << " fixtures (" << fraction_incorrect * 100 << "%) on incorrect side of object. Deleted from consideration.");
        }

        // - Creating pose goal for robot base
        geometry_msgs::Pose base_goal;
        std::vector<float> centroid {position_sums[0] / cloud_fixtures->points.size(), position_sums[1] / cloud_fixtures->points.size(), position_sums[2] / cloud_fixtures->points.size()};
        std::vector<float> normal_averages {normal_sums[0] / cloud_fixtures->points.size(), normal_sums[1] / cloud_fixtures->points.size(), normal_sums[2] / cloud_fixtures->points.size()};

        // - Keeping quadruped in upright orientation
        Eigen::Vector3d x_basis(1, 0, 0);
        Eigen::Vector3d y_basis(0, 1, 0);
        Eigen::Vector3d z_basis(0, 0, 1);
        
        Eigen::Vector3d reference_axis;
        reference_axis(0) = reference_axis_[0];
        reference_axis(1) = reference_axis_[1];
        reference_axis(2) = reference_axis_[2];
        
        Eigen::Vector3d cluster_raw_normal(-1 * normal_averages[0], -1 * normal_averages[1], -1 * normal_averages[2]);
        float x_comp = cluster_raw_normal.dot(x_basis);
        float y_comp = cluster_raw_normal.dot(y_basis);
        float z_comp = 0;                // - want vector to only lie in the XY-plane
        Eigen::Vector3d normal(x_comp, y_comp, z_comp);
        normal.normalize();

        // - Using the planar projection of the surface normal vector with added z-offset
        base_goal.position.x = centroid[0] + surface_offset_ * -1 * normal[0] + base_bias_offset_ * normal_averages[0];
        base_goal.position.y = centroid[1] + surface_offset_ * -1 * normal[1] + base_bias_offset_ * normal_averages[1];
        if (ground_base_) {
            base_goal.position.z = fixed_base_height_;
        } else {
            // base_goal.position.z = centroid[2] + surface_offset_ * -1 * normal[2] + base_bias_offset_ * normal_averages[2] + base_z_offset_;
            base_goal.position.z = centroid[2] + base_z_offset_;
        }

        Eigen::Quaterniond q;
        Eigen::Vector3d a = reference_axis.cross(normal);

        double w {reference_axis.norm() * normal.norm() + reference_axis.dot(normal)};
        q.w() = w;
        q.vec() = a;
        q.normalize();
        if (abs(1 - (pow(q.w(), 2) + pow(q.x(), 2) + pow(q.y(), 2) + pow(q.z(), 2))) > 0.05) {
            ROS_WARN_STREAM("Could not construct a valid quaternion for base pose of a cluster. Defaulting to (1,0,0,0).");
            q.w() = 1.0;
            q.x() = 0.0;
            q.y() = 0.0;
            q.z() = 0.0;
        }

        base_goal.orientation.w = q.w();
        base_goal.orientation.x = q.vec()[0];
        base_goal.orientation.y = q.vec()[1];
        base_goal.orientation.z = q.vec()[2];

        // - Creating pose goal for camera (only necessary as a QoL update because of dumb spherical viewing property of pcl::visualization class)
        geometry_msgs::Pose camera_goal;
        camera_goal.position.x = centroid[0];
        camera_goal.position.y = centroid[1];
        camera_goal.position.z = centroid[2];

        Eigen::Vector3d normal2(-1 * normal_averages[0], -1 * normal_averages[1], -1 * normal_averages[2]);
        Eigen::Quaterniond q2;
        Eigen::Vector3d a2 = reference_axis.cross(normal2);
        double w2 {reference_axis.norm() * normal2.norm() + reference_axis.dot(normal2)};
        q2.w() = w2;
        q2.vec() = a2;
        q2.normalize();

        camera_goal.orientation.w = q2.w();
        camera_goal.orientation.x = q2.vec()[0];
        camera_goal.orientation.y = q2.vec()[1];
        camera_goal.orientation.z = q2.vec()[2];

        // - Adding cluster to final output vector
        cloud_msg.header.frame_id = output_frame_;
        clusters.push_back(cloud_msg);

        // - Converting to pc2 message and adding to the output vector of fixtures for each cluster
        sensor_msgs::PointCloud2 msg_fixtures;
        pcl::toROSMsg(*cloud_fixtures_downsampled, msg_fixtures);
        msg_fixtures.header.frame_id = output_frame_;
        fixtures.push_back(msg_fixtures);

        // - Adding pose goal to array
        goal_poses.push_back(base_goal);

        // - Adding camera goal to array
        camera_poses.push_back(camera_goal);
    }

    // - Adding outputs to service response
    res.clusters = clusters;
    res.vfs = fixtures;
    res.base_poses = goal_poses;
    res.camera_poses = camera_poses;

    return true;
}

// - Splitting clusters based on directions of normal vectors
void VFGenerationServer::splitClusters (const std::vector<sensor_msgs::PointCloud2> &raw_clusters, std::vector<sensor_msgs::PointCloud2> &split_clusters)
{
    for (sensor_msgs::PointCloud2 cloud_msg : raw_clusters) {
        PointCloud::Ptr cloud (new PointCloud);
        pcl::fromROSMsg(cloud_msg, *cloud);
    
        // - loop through cloud and calculate the average normals
        std::vector<float> normal_sums {0.f, 0.f, 0.f};
        for (int i = 0; i < cloud->points.size(); i++) {
            normal_sums[0] += cloud->points[i].normal_x;
            normal_sums[1] += cloud->points[i].normal_y;
            normal_sums[2] += cloud->points[i].normal_z;
        }
        std::vector<float> normal_averages {normal_sums[0] / cloud->points.size(), normal_sums[1] / cloud->points.size(), normal_sums[2] / cloud->points.size()};
        
        // - now construct two clouds for the points on either side of a surface
        PointCloud::Ptr pos_cloud (new PointCloud);
        PointCloud::Ptr neg_cloud (new PointCloud);
        for (int i = 0; i < cloud->points.size(); i++) {
            // - calculate the dot product between the average normal vector and each point's normal vector
            double dot_product {cloud->points[i].normal_x * normal_averages[0] + cloud->points[i].normal_y * normal_averages[1] + cloud->points[i].normal_z * normal_averages[2]};
            
            if (dot_product >= 0) {
                pos_cloud->points.push_back(cloud->points[i]);
            } else {
                neg_cloud->points.push_back(cloud->points[i]);
            }
        }
        
        // - convert them to pc2 msgs and append to the clusters output list
        sensor_msgs::PointCloud2 pos_msg;
        sensor_msgs::PointCloud2 neg_msg;
        pcl::toROSMsg(*pos_cloud, pos_msg);
        pcl::toROSMsg(*neg_cloud, neg_msg);

        split_clusters.push_back(pos_msg);
        split_clusters.push_back(neg_msg);
    }
}

// - Function to upsample clouds
void VFGenerationServer::upsampleCloud (PointCloud::Ptr &input, PointCloud::Ptr &output, double sampling_radius, double step_size, double search_radius, int polynomial_order)
{
    if (input->points.size() <= 0) {
        *output = *input;
        return;
    }

    PointCloud::Ptr dense_points (new PointCloud);
    pcl::search::KdTree<PointT>::Ptr kd_tree (new pcl::search::KdTree<PointT> ());
    pcl::MovingLeastSquares<PointT, PointT> mls;

    double gauss_param = (double)std::pow(search_radius, 2);

    mls.setComputeNormals(false);
    mls.setInputCloud(input);
    mls.setSearchMethod(kd_tree);
    mls.setSearchRadius(search_radius);
    mls.setUpsamplingMethod(
        pcl::MovingLeastSquares<PointT, PointT>::UpsamplingMethod::SAMPLE_LOCAL_PLANE);
    mls.setUpsamplingRadius(sampling_radius);
    mls.setUpsamplingStepSize(step_size);
    mls.setPolynomialOrder(polynomial_order);
    mls.setSqrGaussParam(gauss_param);
    mls.setCacheMLSResults(true);
    mls.setNumberOfThreads(1);

    mls.process(*dense_points);

    *output = *input;
    *output += *dense_points;
}

// - Function to donwsample clouds while transferring over the fields that still matter to me
void VFGenerationServer::downsampleCloud (PointCloud::Ptr &input, PointCloud::Ptr &reference, PointCloud::Ptr &output, float voxel_leaf_size)
{
    if (input->points.size() <= 0) {
        *output = *input;
        return;
    }

    int K {};
    nh_.getParam("/surface_repair/processing/virtual_fixtures/generation/downsample_neighbors", K);

    // - Convert input cloud to different type
    pcl::PointCloud<pcl::PointNormal>::Ptr normal_cloud (new pcl::PointCloud<pcl::PointNormal>);
    pcl::copyPointCloud(*input, *normal_cloud);

    // - Downsample using vox filter
    pcl::VoxelGrid<pcl::PointNormal> vox;
    vox.setInputCloud(normal_cloud);
    vox.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
    pcl::PointCloud<pcl::PointNormal>::Ptr downsampled_cloud (new pcl::PointCloud<pcl::PointNormal>);
    vox.filter(*downsampled_cloud);

    // - Copy voxelized cloud to output
    pcl::copyPointCloud(*downsampled_cloud, *output);

    // - Search original cloud at locations of points in output using kdtree and assign to the output cloud
    pcl::KdTreeFLANN<PointT> kdtree;
    kdtree.setInputCloud(reference);

    struct SeenPositions
    {
        std::vector<float> position;
        int frequency=0;
    };

    struct NormalAccumulator
    {
        float x=0;
        float y=0;
        float z=0;
    };

    // - Updating K to be less than the size of the point cloud if the input K is too big
    // - This is a bit heuristic, perhaps it should be replaced at some point
    if (K > (static_cast<float>(reference->points.size()) / 2)) {
        K = ceil(static_cast<float>(reference->points.size()) / 2);
    }

    // - Loop through points in output cloud
    for (std::size_t i = 0; i < output->points.size(); i++) {
        std::vector<int> pointIdxKNNSearch(K);
        std::vector<float> pointKNNSquaredDistance(K);

        // - Find nearest neighbors in input cloud
        if (kdtree.nearestKSearch (output->points[i], K, pointIdxKNNSearch, pointKNNSquaredDistance) > 0) {
            // - Take average normal of surrounding points and mode viewpoint            
            std::vector<SeenPositions> unique_positions;
            NormalAccumulator normals_accumulator;

            // - Loop through points from search
            for (std::size_t j = 0; j < pointIdxKNNSearch.size(); j++) {
                // - Compare sensor_pos to all stored vectors in unique_positions
                std::vector<float> sensor_pos {std::round(100 * (*input)[pointIdxKNNSearch[j]].sensor_a) / 100, std::round(100 * (*input)[pointIdxKNNSearch[j]].sensor_b) / 100, std::round(100 * (*input)[pointIdxKNNSearch[j]].sensor_c) / 100};
                
                bool found_position {false};
                for (std::size_t k = 0; k < unique_positions.size(); k++) {
                    if (sensor_pos == unique_positions[k].position) {
                        unique_positions[k].frequency++;
                        found_position = true;
                        break;
                    }
                }
                if (!found_position) {
                    SeenPositions pos;
                    pos.position = sensor_pos;
                    pos.frequency = 0;
                    unique_positions.push_back(pos);
                }

                // - Accumulate normal components
                normals_accumulator.x += (*input)[pointIdxKNNSearch[j]].normal_x;
                normals_accumulator.y += (*input)[pointIdxKNNSearch[j]].normal_y;
                normals_accumulator.z += (*input)[pointIdxKNNSearch[j]].normal_z;
            }

            // - Now find the highest frequency result for sensor position
            int highest_frequency_index {0};
            for (std::size_t j = 1; j < unique_positions.size(); j++) {
                if (unique_positions[j].frequency > unique_positions[highest_frequency_index].frequency) {
                    highest_frequency_index = static_cast<int>(j);
                }
            }

            // - And assign the mode sensor pos value to the point in the voxelized cloud
            output->points[i].sensor_a = unique_positions[highest_frequency_index].position[0];
            output->points[i].sensor_b = unique_positions[highest_frequency_index].position[1];
            output->points[i].sensor_c = unique_positions[highest_frequency_index].position[2];
            
            // - Calculate the average normal components and assign to the voxelized cloud
            Eigen::Vector3f normal_vector (normals_accumulator.x / pointIdxKNNSearch.size(), normals_accumulator.y / pointIdxKNNSearch.size(), normals_accumulator.z / pointIdxKNNSearch.size());
            normal_vector.normalize();
            output->points[i].normal_x = normal_vector(0);
            output->points[i].normal_y = normal_vector(1);
            output->points[i].normal_z = normal_vector(2);
        } else {
            ROS_ERROR_STREAM("NKN search failed! Size of vector is " << pointIdxKNNSearch.size());
        }
    }
}

int main (int argc, char** argv) 
{
    ros::init(argc, argv, "vf_generation_server");
    VFGenerationServer vf_generation_server;

    return 0;
}
